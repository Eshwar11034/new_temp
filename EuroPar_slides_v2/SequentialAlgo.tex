% Slide: The Target Sequential Algorithm (Revised) - CORRECTED
\begin{frame}{The Sequential QR Algorithm}
  \begin{columns}[c,onlytextwidth] % Vertically center the columns

    % ----- LEFT: The algorithm, with key kernels highlighted -----
    \column{0.55\textwidth}
    \begin{block}{Algorithm 2: The Core Logic}
      \footnotesize % Use a slightly smaller font to ensure it fits well
      \begin{algorithmic}[1]
        \State \textbf{Input:} $A$, a $m \times n$ non-singular real matrix.
        \For{$i = 1$ \textbf{to} $m$}
          % Highlight the pivot kernel in blue
          \State $(up, b) \gets \textcolor{pivotblue}{\Call{\texttt{update\_pivot\_row}}{A, i}}$
          \For{$j = i+1$ to $n$}
            % Highlight the update kernel in green
            \State \textcolor{updategreen}{\Call{\texttt{update\_trailing\_non\_pivot\_row}}{A, i, j, up}}
          \EndFor
        \EndFor
        \State \textbf{Output:} Matrix $A$ in upper-triangular form.
      \end{algorithmic}
    \end{block}

    % ----- RIGHT: Explanation focused on dependency, not memory layout -----
    \column{0.40\textwidth}
    \begin{block}{Key Characteristics}
      This is the algorithm at the core of the SLSQP bottleneck. It consists of two main computational kernels:
      \begin{itemize}
        % --- FIX APPLIED HERE ---
        \item \textcolor{pivotblue}{\texttt{update\_pivot\_row}}\normalcolor
        \item \textcolor{updategreen}{\texttt{update\_trailing\_non\\\_pivot\_row}}\normalcolor
        % --- AND HERE ---
      \end{itemize}
      \vspace{2mm}
      It has a classic nested-loop structure with a critical \textbf{data dependency}.
    \end{block}
    
  \end{columns}
\end{frame}