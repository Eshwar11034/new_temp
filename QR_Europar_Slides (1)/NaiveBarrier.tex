% % Slide: Naive Barrier-Based Parallelism
% \begin{frame}{A Naive Approach: Parallelism with Barriers}
%   \begin{columns}[c,onlytextwidth] % Vertically center the columns

%     % ----- LEFT: The algorithm modified with a parallel loop and barriers -----
%     \column{0.55\textwidth}
%     \begin{block}{Barrier-Based Parallel Algorithm}
%       \footnotesize
%       \begin{algorithmic}[1]
%         \State \textbf{Input:} $A$, a $m \times n$ non-singular real matrix.
%         \For{$i = 1$ \textbf{to} $m$} \Comment{Outer loop remains sequential}
%           \State $(up, b) \gets \textcolor{pivotblue}{\Call{\texttt{update\_pivot\_row}}{A, i}}$
%           \State \textcolor{depred}{\textbf{--- BARRIER 1 ---}} \Comment{Wait for pivot to complete}
          
%           \ParallelFor{$j = i+1$ to $n$} \Comment{Parallelize row updates}
%             \State \textcolor{updategreen}{\Call{\texttt{update\_trailing\_non\_pivot\_row}}{A, i, j, up}}
%           \EndParallelFor
          
%           \State \textcolor{depred}{\textbf{--- BARRIER 2 ---}} \Comment{Wait for all updates to finish}
%         \EndFor
%         \State \textbf{Output:} Matrix $A$ in upper-triangular form.
%       \end{algorithmic}
%     \end{block}
% \end{columns}
%     % % ----- RIGHT: Explanation of the logic and its critical flaw -----
%     % \column{0.45\textwidth}
%     % \begin{block}{The Logic}
%     %   The most obvious way to parallelize the algorithm is to execute the inner loop across multiple threads. To maintain correctness:
%     %   \begin{itemize}
%     %     \item \textbf{Barrier 1} is needed to ensure the pivot data is ready before any thread can start an update.
%     %     \item \textbf{Barrier 2} is needed to ensure all row updates for iteration `i` are complete before we begin iteration `i+1`.
%     %   \end{itemize}
%     % \end{block}
    
%     % \begin{alertblock}{The Critical Flaw: Lost Performance}
%     %   This approach is inefficient. Threads that finish their work quickly are forced to \textbf{idle} at the barrier, waiting for the single \textbf{slowest thread} to catch up. This "tail waiting" is pure wasted time.
%     % \end{alertblock}
% \end{frame}


\begin{frame}{A Naive Approach: Parallelism with Barriers}
	
	\pause 
	\begin{columns}[c] % Vertically center the columns' content
	
	 % ----- LEFT: The algorithm -----
	 \begin{column}{0.55\textwidth}
	   \begin{block}{Barrier-Based Parallel Algorithm}
	     \footnotesize
	     \begin{algorithmic}[1]
	       \State \textbf{Input:} $A$, a $m \times n$ non-singular real matrix.
	       \For{$i = 1$ \textbf{to} $m$}
	         \State $(up, b) \gets \textcolor{pivotblue}{\Call{\texttt{update\_pivot\_row}}{A, i}}$
	         \State \textcolor{depred}{\textbf{--- BARRIER 1 ---}}
	         
	         \For{$j = i+1$ to $n$} \Comment{Parallel execution}
	           \State \textcolor{updategreen}{\Call{\texttt{update\_trailing\_non\_pivot\_row}}{A, i, j, up}}
	         \EndFor
	         
	         \State \textcolor{depred}{\textbf{--- BARRIER 2 ---}}
	       \EndFor
	       \State \textbf{Output:} Matrix $A$ in upper-triangular form.
	     \end{algorithmic}
	   \end{block}
	 \end{column}
	\end{columns}
\end{frame}