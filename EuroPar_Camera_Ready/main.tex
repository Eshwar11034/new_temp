    % This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.21 of 2022/01/12
%
\documentclass[runningheads]{llncs}
%
\usepackage[T1]{fontenc}
% T1 fonts will be used to generate the final print and online PDFs,
% so please use T1 fonts in your manuscript whenever possible.
% Other font encondings may result in incorrect characters.
%
\usepackage{graphicx}
%\usepackage{titlesec}

\usepackage{hyperref}
% If you use the hyperref package, please uncomment the following two lines
% to display URLs in blue roman font according to Springer's eBook style:
\usepackage{color}
\renewcommand\UrlFont{\color{blue}\rmfamily}
\urlstyle{rm}

\usepackage{amsmath,amssymb,amsfonts}
%\renewcommand{\vec}[1]{\mathbf{#1}}

\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{xspace}
\usepackage{todonotes}
\usepackage{url}
\usepackage{enumitem}
\makeatletter
\newcommand{\Continue}{
  \State \textbf{continue}
}
\makeatother

\usepackage{graphicx}
\usepackage{pgfplots}
\usepackage{tikz}
%\usepackage{tikz-network}
\usetikzlibrary{automata, positioning}
\usetikzlibrary{shapes.geometric, arrows}

\usetikzlibrary{positioning, arrows.meta}
\usepackage{textcomp}
\usepackage{xcolor}

% Define light blue color
\definecolor{lightblue}{RGB}{173, 216, 230}

\usepackage{subcaption}
\pgfplotsset{compat=1.17} % Adjust to your installed version

\usepackage{bbding}
\usepackage{biblatex}
\addbibresource{refs.bib}

\definecolor{darkgreen}{rgb}{0.0, 0.35, 0.0} % Define dark green color

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\input{macros}

\begin{document}

\title{Efficient Task Graph Scheduling for Parallel QR Factorization in SLSQP\thanks{GitHub Repository: \url{https://github.com/PDCRL/ParSQP}}}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{
Soumyajit Chatterjee \inst{1} \Envelope  \and
Rahul Utkoor\inst{2}\and
Uppu Eshwar\inst{1} \and
Sathya Peri\inst{1}\and
V.Krishna Nandivada\inst{3}
}

\institute{Indian Institute of Technology, Hyderabad\\
\email{\{ai22mtech02005@, ch21btech11034@, sathya\_p@cse}\}.iith.ac.in \and
QUALCOMM India Private Limited\\
\email{rutkoor@qti.qualcomm.com} \and
Indian Institute of Technology, Madras\\
\email{nvk@iitm.ac.in}
}

\titlerunning{Efficient Task Graph Scheduling for Parallel QR Factorization}
\authorrunning{Chatterjee et al.}

\maketitle              

\begin{abstract}
Efficient task scheduling is paramount in parallel programming on multi-core architectures, where tasks are fundamental computational units. QR factorization is a critical sub-routine in Sequential Least Squares Quadratic Programming (SLSQP) for solving non-linear programming (NLP) problems. QR factorization decomposes a matrix into an orthogonal matrix Q and an upper triangular matrix R, which are essential for solving systems of linear equations arising from optimization problems. SLSQP uses an in-place version of QR factorization, which requires storing intermediate results for the next steps of the algorithm. Although DAG-based approaches for QR factorization are prevalent in the literature, they often lack control over the intermediate kernel results, providing only the final output matrices Q and R. This limitation is particularly challenging in SLSQP, where intermediate results of QR factorization are crucial for back-substitution logic at each iteration. Our work introduces novel scheduling techniques using a two-queue approach to execute the QR factorization kernel effectively. This approach, implemented in high-level C++ programming language, facilitates compiler optimizations and allows storing intermediate results required by back-substitution logic. Empirical evaluations demonstrate substantial performance gains, including a 10x improvement over the sequential QR version of the SLSQP algorithm.

\keywords{Non Linear Programming \and Parallel Computing \and DAG Sch-eduling.}
\end{abstract}


\section{Introduction}
\label{sec:intro}
\input{intro}

\section{Background}
\label{sec:bkgd}
\input{background}


\section{Our Methodology: Efficient Parallel QR Factorization}
\label{sec:meth}
\input{methodology}

\section{Experimental Results}
\label{sec:expts}
\input{expts} 

\section{Related Works}
\label{sec:related}
\input{related}

\section{Conclusions and Future Work}
\label{sec:conc}
\input{conc}

\section{Acknowledgments and Artifact Availability}
We extend our deepest gratitude to Dr. Saravanan, Professor of Civil Engineering, Indian Institute of Technology, Madras, for providing us  with the dataset for the experiment \hyperref[exp:exp4]{4.4}. We also thank the anonymous reviewers for their useful comments. The artifact for this work is available in the Zenodo repository \cite{soumyajit_chatterjee_2025_15602262}.

\small \subsubsection{Disclosure of Interests.} This work is partly funded by CRG 009391 \& 001090, GoI (Government of India).

%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.

%\bibliographystyle{splncs04}
%\bibliography{refs}
\printbibliography
\end{document}

% \begin{algorithm}
%  \caption{\texttt{update\_trailing\_non\_pivot\_row}} \label{alg:update_trailing}
%  \begin{algorithmic}[1]
%     \State \textbf{Input:}
%     \begin{itemize}
%         \item Matrix \texttt{mat} of size $m\times n$,
%         \item Pivot row index $lpivot$,
%         \item Row index $j$ to be updated with pivot row,
%         \item Pivot update $up$ and scaling factor $b$.
%     \end{itemize}
%     \State $sm \gets mat[j,lpivot]\cdot up + \text{dot}\Big(mat[j,lpivot+1:n-1],\,mat[lpivot,lpivot+1:n-1]\Big)$
%     \If{$sm = 0$}
%          \State \Return
%     \EndIf
%     \State $sm \gets sm \cdot b$
%     \State $mat[j,lpivot] \gets mat[j,lpivot] + sm\cdot up$
%     \State $mat[j,lpivot+1:n-1] \gets mat[j,lpivot+1:n-1] + sm\cdot mat[lpivot,lpivot+1:n-1]$
%  \end{algorithmic}
% \end{algorithm}


% \begin{algorithm}
%  \caption{\texttt{update\_pivot\_row}} \label{alg:update_pivot_row}
%  \begin{algorithmic}[1]
%     \State \textbf{Input:}
%     \begin{itemize}
%         \item Matrix \texttt{mat} of size $m\times n$,
%         \item Pivot row index $lpivot$.
%     \end{itemize}
%     \State $cl \gets \max\Big(|mat[lpivot,lpivot]|,\;\max_{k=lpivot+1}^{n-1}|mat[lpivot,k]|\Big)$
%     \State $sm1 \gets \sum_{k=lpivot+1}^{n-1}\Big(|mat[lpivot,k]|\Big)^2$
%     \If{$cl \le 0$}
%          \State \Return \textbf{undefined} \Comment{No valid pivot.}
%     \EndIf
%     \State $clinv \gets 1/cl$
%     \State $sm \gets \Big(mat[lpivot,lpivot]\cdot clinv\Big)^2 + sm1\cdot clinv^2$
%     \State $cl \gets cl\cdot \sqrt{sm}$
%     \If{$mat[lpivot,lpivot] > 0$}
%          \State $cl \gets -cl$
%     \EndIf
%     \State $up \gets mat[lpivot,lpivot] - cl$
%     \State $mat[lpivot,lpivot] \gets cl$
%     \State $b \gets up \cdot mat[lpivot,lpivot]$
%     \If{$b \ge 0$}
%          \State \Return \textbf{undefined} \Comment{Invalid scaling factor.}
%     \EndIf
%     \State $b \gets 1/b$
%     \State \Return $(up,\, b)$
%  \end{algorithmic}
% \end{algorithm}

